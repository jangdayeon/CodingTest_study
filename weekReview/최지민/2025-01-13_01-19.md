### 10주차(2025.01.13 - 2025.01.19) 리뷰 🤔

**1. 이진 변환 반복하기 (70129)**
```
int zeroCnt = (int) sLength.chars().filter(c -> c == '0').count();
```
- chars(): 문자열의 각 문자를 **아스키 코드 값(IntStream)**으로 변환하여 반환
- filter(): 조건에 따른 원소만 추출
- count(): 조건을 만족하는 요소의 개수를 반환 (반환타입: long)
    - count()의 반환타입이 long이므로 int로 사용하려면 강제 형변환 필요

- 정수를 이진수 문자열로 변환하는 방법
    - Integer.toBinaryString(len)
        - 정수를 **2진수 문자열로 변환**하는 전용 메소드
    - Integer.toString(len, 2)
        - 10진수를 원하는 **진법의 문자열로 변환**
    - toBinaryString이 내부적으로 toString을 호출하기 때문에 **속도 상 차이는 없음!**

<br><hr><br>

**2. 숫자의 표현 (12924)**
- **투포인터 알고리즘**
    - 연속된 자연수의 합이 n이 되는 경우의 수를 찾는 문제
    - 투포인터 활용법:
        - 두 개의 포인터(`start`, `end`)를 이동시키며 합을 구함
        - `sum == n` 이면 경우의 수 증가
        - `sum < n` 이면 end를 증가시켜 더 큰 값을 포함
        - `sum > n` 이면 start를 증가시켜 더 작은 값부터 제거
    ✔️ 특정 범위에서 연속된 값의 합을 구하는 문제, 두 포인터의 합과 차를 구하는 문제에서는 투포인터가 효과적!

- 연속된 자연수의 합을 구하는 **n = k(k+1)/2 공식(등차수열의 합 공식)**을 통해 구하는 방법도 기억하기

<br><hr><br>

**3. 다음 큰 숫자 (12911)**
- `Integer.bitCount(n)`: 주어진 정수의 2진수 표현에서 **true(1) bit의 개수**를 찾는 함수!

<br><hr><br>

**4. 피보나치 수 (12945)**
- 피보나치 수열 구현
    - 두 개의 변수를 통해 수를 계속 갱신하며 계산
    - DP 방식 사용 (Bottom-up 방식)
    - 재귀 사용

<br><hr><br>

✅ 총평
- 투 포인터 코드나 피보나치 코드 짤 때 좀 더 깔끔하게 짜기
    - 돌아가는 원리를 잘 생각하면서!
- 비트 연산시에 **bitCount** 함수 생각하기